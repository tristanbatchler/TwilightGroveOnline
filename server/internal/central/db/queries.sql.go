// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: queries.sql

package db

import (
	"context"
)

const createActor = `-- name: CreateActor :one
INSERT INTO actors (
    user_id, name, level_id, x, y
) VALUES (
    ?, ?, ?, ?, ?
)
RETURNING id, user_id, name, level_id, x, y
`

type CreateActorParams struct {
	UserID  int64
	Name    string
	LevelID int64
	X       int64
	Y       int64
}

func (q *Queries) CreateActor(ctx context.Context, arg CreateActorParams) (Actor, error) {
	row := q.db.QueryRowContext(ctx, createActor,
		arg.UserID,
		arg.Name,
		arg.LevelID,
		arg.X,
		arg.Y,
	)
	var i Actor
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Name,
		&i.LevelID,
		&i.X,
		&i.Y,
	)
	return i, err
}

const createActorIfNotExists = `-- name: CreateActorIfNotExists :one
INSERT INTO actors (
    user_id, name, level_id, x, y
) VALUES (
    ?, ?, ?, ?, ?
)
ON CONFLICT (user_id) DO NOTHING
RETURNING id, user_id, name, level_id, x, y
`

type CreateActorIfNotExistsParams struct {
	UserID  int64
	Name    string
	LevelID int64
	X       int64
	Y       int64
}

func (q *Queries) CreateActorIfNotExists(ctx context.Context, arg CreateActorIfNotExistsParams) (Actor, error) {
	row := q.db.QueryRowContext(ctx, createActorIfNotExists,
		arg.UserID,
		arg.Name,
		arg.LevelID,
		arg.X,
		arg.Y,
	)
	var i Actor
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Name,
		&i.LevelID,
		&i.X,
		&i.Y,
	)
	return i, err
}

const createAdminIfNotExists = `-- name: CreateAdminIfNotExists :one
INSERT INTO admins (
    user_id
) VALUES (
    ?
)
ON CONFLICT (user_id) DO NOTHING
RETURNING id, user_id
`

func (q *Queries) CreateAdminIfNotExists(ctx context.Context, userID int64) (Admin, error) {
	row := q.db.QueryRowContext(ctx, createAdminIfNotExists, userID)
	var i Admin
	err := row.Scan(&i.ID, &i.UserID)
	return i, err
}

const createLevel = `-- name: CreateLevel :one
INSERT INTO levels (
    gd_res_path, added_by_user_id, last_updated_by_user_id
) VALUES (
    ?, ?, ?
)
RETURNING id, gd_res_path, added_by_user_id, added, last_updated_by_user_id, last_updated, "foreign"
`

type CreateLevelParams struct {
	GdResPath           string
	AddedByUserID       int64
	LastUpdatedByUserID int64
}

func (q *Queries) CreateLevel(ctx context.Context, arg CreateLevelParams) (Level, error) {
	row := q.db.QueryRowContext(ctx, createLevel, arg.GdResPath, arg.AddedByUserID, arg.LastUpdatedByUserID)
	var i Level
	err := row.Scan(
		&i.ID,
		&i.GdResPath,
		&i.AddedByUserID,
		&i.Added,
		&i.LastUpdatedByUserID,
		&i.LastUpdated,
		&i.Foreign,
	)
	return i, err
}

const createLevelCollisionPoint = `-- name: CreateLevelCollisionPoint :one
INSERT INTO levels_collision_points (
    level_id, x, y
) VALUES (
    ?, ?, ?
)
RETURNING id, level_id, x, y
`

type CreateLevelCollisionPointParams struct {
	LevelID int64
	X       int64
	Y       int64
}

func (q *Queries) CreateLevelCollisionPoint(ctx context.Context, arg CreateLevelCollisionPointParams) (LevelsCollisionPoint, error) {
	row := q.db.QueryRowContext(ctx, createLevelCollisionPoint, arg.LevelID, arg.X, arg.Y)
	var i LevelsCollisionPoint
	err := row.Scan(
		&i.ID,
		&i.LevelID,
		&i.X,
		&i.Y,
	)
	return i, err
}

const createLevelDoor = `-- name: CreateLevelDoor :one
INSERT INTO levels_doors (
    level_id, destination_level_id, destination_x, destination_y, x, y
) VALUES (
    ?, ?, ?, ?, ?, ?
)
RETURNING id, level_id, destination_level_id, destination_x, destination_y, x, y
`

type CreateLevelDoorParams struct {
	LevelID            int64
	DestinationLevelID int64
	DestinationX       int64
	DestinationY       int64
	X                  int64
	Y                  int64
}

func (q *Queries) CreateLevelDoor(ctx context.Context, arg CreateLevelDoorParams) (LevelsDoor, error) {
	row := q.db.QueryRowContext(ctx, createLevelDoor,
		arg.LevelID,
		arg.DestinationLevelID,
		arg.DestinationX,
		arg.DestinationY,
		arg.X,
		arg.Y,
	)
	var i LevelsDoor
	err := row.Scan(
		&i.ID,
		&i.LevelID,
		&i.DestinationLevelID,
		&i.DestinationX,
		&i.DestinationY,
		&i.X,
		&i.Y,
	)
	return i, err
}

const createLevelShrub = `-- name: CreateLevelShrub :one
INSERT INTO levels_shrubs (
    level_id, strength, x, y
) VALUES (
    ?, ?, ?, ?
)
RETURNING id, level_id, strength, x, y
`

type CreateLevelShrubParams struct {
	LevelID  int64
	Strength int64
	X        int64
	Y        int64
}

func (q *Queries) CreateLevelShrub(ctx context.Context, arg CreateLevelShrubParams) (LevelsShrub, error) {
	row := q.db.QueryRowContext(ctx, createLevelShrub,
		arg.LevelID,
		arg.Strength,
		arg.X,
		arg.Y,
	)
	var i LevelsShrub
	err := row.Scan(
		&i.ID,
		&i.LevelID,
		&i.Strength,
		&i.X,
		&i.Y,
	)
	return i, err
}

const createUser = `-- name: CreateUser :one
INSERT INTO users (
    username, password_hash
) VALUES (
    ?, ?
)
RETURNING id, username, password_hash
`

type CreateUserParams struct {
	Username     string
	PasswordHash string
}

func (q *Queries) CreateUser(ctx context.Context, arg CreateUserParams) (User, error) {
	row := q.db.QueryRowContext(ctx, createUser, arg.Username, arg.PasswordHash)
	var i User
	err := row.Scan(&i.ID, &i.Username, &i.PasswordHash)
	return i, err
}

const createUserIfNotExists = `-- name: CreateUserIfNotExists :one
INSERT INTO users (
    username, password_hash
) VALUES (
    ?, ?
)
ON CONFLICT (username) DO NOTHING
RETURNING id, username, password_hash
`

type CreateUserIfNotExistsParams struct {
	Username     string
	PasswordHash string
}

func (q *Queries) CreateUserIfNotExists(ctx context.Context, arg CreateUserIfNotExistsParams) (User, error) {
	row := q.db.QueryRowContext(ctx, createUserIfNotExists, arg.Username, arg.PasswordHash)
	var i User
	err := row.Scan(&i.ID, &i.Username, &i.PasswordHash)
	return i, err
}

const deleteLevelCollisionPointsByLevelId = `-- name: DeleteLevelCollisionPointsByLevelId :exec
DELETE FROM levels_collision_points
WHERE level_id = ?
`

func (q *Queries) DeleteLevelCollisionPointsByLevelId(ctx context.Context, levelID int64) error {
	_, err := q.db.ExecContext(ctx, deleteLevelCollisionPointsByLevelId, levelID)
	return err
}

const deleteLevelDoorsByLevelId = `-- name: DeleteLevelDoorsByLevelId :exec
DELETE FROM levels_doors
WHERE level_id = ?
`

func (q *Queries) DeleteLevelDoorsByLevelId(ctx context.Context, levelID int64) error {
	_, err := q.db.ExecContext(ctx, deleteLevelDoorsByLevelId, levelID)
	return err
}

const deleteLevelShrubsByLevelId = `-- name: DeleteLevelShrubsByLevelId :exec
DELETE FROM levels_shrubs
WHERE level_id = ?
`

func (q *Queries) DeleteLevelShrubsByLevelId(ctx context.Context, levelID int64) error {
	_, err := q.db.ExecContext(ctx, deleteLevelShrubsByLevelId, levelID)
	return err
}

const deleteLevelTscnDataByLevelId = `-- name: DeleteLevelTscnDataByLevelId :exec
DELETE FROM levels_tscn_data
WHERE level_id = ?
`

func (q *Queries) DeleteLevelTscnDataByLevelId(ctx context.Context, levelID int64) error {
	_, err := q.db.ExecContext(ctx, deleteLevelTscnDataByLevelId, levelID)
	return err
}

const getActorByUserId = `-- name: GetActorByUserId :one
SELECT id, user_id, name, level_id, x, y FROM actors
WHERE user_id = ? LIMIT 1
`

func (q *Queries) GetActorByUserId(ctx context.Context, userID int64) (Actor, error) {
	row := q.db.QueryRowContext(ctx, getActorByUserId, userID)
	var i Actor
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Name,
		&i.LevelID,
		&i.X,
		&i.Y,
	)
	return i, err
}

const getAdminByUserId = `-- name: GetAdminByUserId :one
SELECT id, user_id FROM admins
WHERE user_id = ? LIMIT 1
`

func (q *Queries) GetAdminByUserId(ctx context.Context, userID int64) (Admin, error) {
	row := q.db.QueryRowContext(ctx, getAdminByUserId, userID)
	var i Admin
	err := row.Scan(&i.ID, &i.UserID)
	return i, err
}

const getLevelByGdResPath = `-- name: GetLevelByGdResPath :one
SELECT id, gd_res_path, added_by_user_id, added, last_updated_by_user_id, last_updated, "foreign" FROM levels
WHERE gd_res_path = ? LIMIT 1
`

func (q *Queries) GetLevelByGdResPath(ctx context.Context, gdResPath string) (Level, error) {
	row := q.db.QueryRowContext(ctx, getLevelByGdResPath, gdResPath)
	var i Level
	err := row.Scan(
		&i.ID,
		&i.GdResPath,
		&i.AddedByUserID,
		&i.Added,
		&i.LastUpdatedByUserID,
		&i.LastUpdated,
		&i.Foreign,
	)
	return i, err
}

const getLevelById = `-- name: GetLevelById :one
SELECT id, gd_res_path, added_by_user_id, added, last_updated_by_user_id, last_updated, "foreign" FROM levels
WHERE id = ? LIMIT 1
`

func (q *Queries) GetLevelById(ctx context.Context, id int64) (Level, error) {
	row := q.db.QueryRowContext(ctx, getLevelById, id)
	var i Level
	err := row.Scan(
		&i.ID,
		&i.GdResPath,
		&i.AddedByUserID,
		&i.Added,
		&i.LastUpdatedByUserID,
		&i.LastUpdated,
		&i.Foreign,
	)
	return i, err
}

const getLevelCollisionPointsByLevelId = `-- name: GetLevelCollisionPointsByLevelId :many
SELECT id, level_id, x, y FROM levels_collision_points
WHERE level_id = ?
`

func (q *Queries) GetLevelCollisionPointsByLevelId(ctx context.Context, levelID int64) ([]LevelsCollisionPoint, error) {
	rows, err := q.db.QueryContext(ctx, getLevelCollisionPointsByLevelId, levelID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []LevelsCollisionPoint
	for rows.Next() {
		var i LevelsCollisionPoint
		if err := rows.Scan(
			&i.ID,
			&i.LevelID,
			&i.X,
			&i.Y,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getLevelDoorsByLevelId = `-- name: GetLevelDoorsByLevelId :many
SELECT id, level_id, destination_level_id, destination_x, destination_y, x, y FROM levels_doors
WHERE level_id = ?
`

func (q *Queries) GetLevelDoorsByLevelId(ctx context.Context, levelID int64) ([]LevelsDoor, error) {
	rows, err := q.db.QueryContext(ctx, getLevelDoorsByLevelId, levelID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []LevelsDoor
	for rows.Next() {
		var i LevelsDoor
		if err := rows.Scan(
			&i.ID,
			&i.LevelID,
			&i.DestinationLevelID,
			&i.DestinationX,
			&i.DestinationY,
			&i.X,
			&i.Y,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getLevelIds = `-- name: GetLevelIds :many
SELECT id FROM levels
`

func (q *Queries) GetLevelIds(ctx context.Context) ([]int64, error) {
	rows, err := q.db.QueryContext(ctx, getLevelIds)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []int64
	for rows.Next() {
		var id int64
		if err := rows.Scan(&id); err != nil {
			return nil, err
		}
		items = append(items, id)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getLevelShrubsByLevelId = `-- name: GetLevelShrubsByLevelId :many
SELECT id, level_id, strength, x, y FROM levels_shrubs
WHERE level_id = ?
`

func (q *Queries) GetLevelShrubsByLevelId(ctx context.Context, levelID int64) ([]LevelsShrub, error) {
	rows, err := q.db.QueryContext(ctx, getLevelShrubsByLevelId, levelID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []LevelsShrub
	for rows.Next() {
		var i LevelsShrub
		if err := rows.Scan(
			&i.ID,
			&i.LevelID,
			&i.Strength,
			&i.X,
			&i.Y,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getLevelTscnDataByLevelId = `-- name: GetLevelTscnDataByLevelId :one
SELECT level_id, tscn_data FROM levels_tscn_data
WHERE level_id = ? LIMIT 1
`

func (q *Queries) GetLevelTscnDataByLevelId(ctx context.Context, levelID int64) (LevelsTscnDatum, error) {
	row := q.db.QueryRowContext(ctx, getLevelTscnDataByLevelId, levelID)
	var i LevelsTscnDatum
	err := row.Scan(&i.LevelID, &i.TscnData)
	return i, err
}

const getUserByUsername = `-- name: GetUserByUsername :one
SELECT id, username, password_hash FROM users
WHERE username = ? LIMIT 1
`

func (q *Queries) GetUserByUsername(ctx context.Context, username string) (User, error) {
	row := q.db.QueryRowContext(ctx, getUserByUsername, username)
	var i User
	err := row.Scan(&i.ID, &i.Username, &i.PasswordHash)
	return i, err
}

const getUserIdByActorId = `-- name: GetUserIdByActorId :one
SELECT user_id FROM actors
WHERE id = ? LIMIT 1
`

func (q *Queries) GetUserIdByActorId(ctx context.Context, id int64) (int64, error) {
	row := q.db.QueryRowContext(ctx, getUserIdByActorId, id)
	var user_id int64
	err := row.Scan(&user_id)
	return user_id, err
}

const isActorAdmin = `-- name: IsActorAdmin :one
SELECT 1 FROM users u
JOIN admins ad ON u.id = ad.user_id
JOIN actors ac ON u.id = ac.user_id
WHERE ac.id = ? LIMIT 1
`

func (q *Queries) IsActorAdmin(ctx context.Context, id int64) (int64, error) {
	row := q.db.QueryRowContext(ctx, isActorAdmin, id)
	var column_1 int64
	err := row.Scan(&column_1)
	return column_1, err
}

const updateActorLevel = `-- name: UpdateActorLevel :exec
UPDATE actors
SET level_id = ?
WHERE id = ?
`

type UpdateActorLevelParams struct {
	LevelID int64
	ID      int64
}

func (q *Queries) UpdateActorLevel(ctx context.Context, arg UpdateActorLevelParams) error {
	_, err := q.db.ExecContext(ctx, updateActorLevel, arg.LevelID, arg.ID)
	return err
}

const updateActorLocation = `-- name: UpdateActorLocation :exec
UPDATE actors
SET level_id = ?, x = ?, y = ?
WHERE id = ?
`

type UpdateActorLocationParams struct {
	LevelID int64
	X       int64
	Y       int64
	ID      int64
}

func (q *Queries) UpdateActorLocation(ctx context.Context, arg UpdateActorLocationParams) error {
	_, err := q.db.ExecContext(ctx, updateActorLocation,
		arg.LevelID,
		arg.X,
		arg.Y,
		arg.ID,
	)
	return err
}

const updateLevelLastUpdated = `-- name: UpdateLevelLastUpdated :exec
UPDATE levels
SET last_updated = CURRENT_TIMESTAMP
AND last_updated_by_user_id = ?
WHERE id = ?
`

type UpdateLevelLastUpdatedParams struct {
	LastUpdatedByUserID int64
	ID                  int64
}

func (q *Queries) UpdateLevelLastUpdated(ctx context.Context, arg UpdateLevelLastUpdatedParams) error {
	_, err := q.db.ExecContext(ctx, updateLevelLastUpdated, arg.LastUpdatedByUserID, arg.ID)
	return err
}

const upsertLevelTscnData = `-- name: UpsertLevelTscnData :one
INSERT INTO levels_tscn_data (
    level_id, tscn_data
) VALUES (
    ?, ?
)
ON CONFLICT (level_id) DO UPDATE SET tscn_data = EXCLUDED.tscn_data
RETURNING level_id, tscn_data
`

type UpsertLevelTscnDataParams struct {
	LevelID  int64
	TscnData []byte
}

func (q *Queries) UpsertLevelTscnData(ctx context.Context, arg UpsertLevelTscnDataParams) (LevelsTscnDatum, error) {
	row := q.db.QueryRowContext(ctx, upsertLevelTscnData, arg.LevelID, arg.TscnData)
	var i LevelsTscnDatum
	err := row.Scan(&i.LevelID, &i.TscnData)
	return i, err
}
